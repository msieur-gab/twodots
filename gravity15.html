<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Ball Physics Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
            color: white;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #333;
            background: #000;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }

        button {
            background: #333;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #555;
        }

        button:active {
            background: #777;
        }

        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #666;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 3px;
        }

        .trail {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.6) 0%, rgba(255, 100, 100, 0.3) 50%, transparent 100%);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="controls">
            <button id="fullscreenBtn">Fullscreen</button>
            <button id="resetBtn">Reset Ball</button>
        </div>
        
        <div id="info">
            <div>Tilt your device to control the ball</div>
            <div id="orientation">Orientation: Not detected</div>
            <div id="ballPos">Ball: Loading...</div>
        </div>
    </div>

    <!-- Load libraries from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/screenfull.js/5.2.0/screenfull.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gyronorm@2.0.6/dist/gyronorm.complete.min.js">

    <script>
        class MobileBallGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.orientationInfo = document.getElementById('orientation');
                this.ballPosInfo = document.getElementById('ballPos');
                
                // Game dimensions
                this.gameSize = Math.min(window.innerWidth - 40, window.innerHeight - 100, 400);
                this.canvas.width = this.gameSize;
                this.canvas.height = this.gameSize;
                
                console.log('Canvas size:', this.gameSize);
                
                // Physics world
                this.engine = Matter.Engine.create();
                this.world = this.engine.world;
                this.engine.world.gravity.x = 0;
                this.engine.world.gravity.y = 0;
                
                // Ball trail
                this.trail = [];
                this.maxTrailLength = 8;
                
                this.init();
                this.setupControls();
                this.startOrientationTracking();
                this.gameLoop();
            }
            
            init() {
                // Create boundaries
                const wallThickness = 20;
                const walls = [
                    // Top wall
                    Matter.Bodies.rectangle(this.gameSize / 2, -wallThickness / 2, this.gameSize, wallThickness, { 
                        isStatic: true,
                        render: { fillStyle: '#333' }
                    }),
                    // Bottom wall
                    Matter.Bodies.rectangle(this.gameSize / 2, this.gameSize + wallThickness / 2, this.gameSize, wallThickness, { 
                        isStatic: true,
                        render: { fillStyle: '#333' }
                    }),
                    // Left wall
                    Matter.Bodies.rectangle(-wallThickness / 2, this.gameSize / 2, wallThickness, this.gameSize, { 
                        isStatic: true,
                        render: { fillStyle: '#333' }
                    }),
                    // Right wall
                    Matter.Bodies.rectangle(this.gameSize + wallThickness / 2, this.gameSize / 2, wallThickness, this.gameSize, { 
                        isStatic: true,
                        render: { fillStyle: '#333' }
                    })
                ];
                
                Matter.World.add(this.world, walls);
                
                // Create ball
                this.createBall();
            }
            
            createBall() {
                if (this.ball) {
                    Matter.World.remove(this.world, this.ball);
                }
                
                const ballX = this.gameSize / 2;
                const ballY = this.gameSize / 2;
                
                this.ball = Matter.Bodies.circle(ballX, ballY, 20, {
                    restitution: 0.8,
                    friction: 0.1,
                    frictionAir: 0.01,
                    render: { fillStyle: '#ff0000' }
                });
                
                Matter.World.add(this.world, this.ball);
                this.trail = [];
                
                console.log('Ball created at:', ballX, ballY, 'Canvas size:', this.gameSize);
            }
            
            setupControls() {
                // Fullscreen button
                document.getElementById('fullscreenBtn').addEventListener('click', () => {
                    if (screenfull && screenfull.isEnabled) {
                        screenfull.toggle();
                    }
                });
                
                // Reset button
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.createBall();
                });
                
                // Handle orientation change
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.handleResize();
                    }, 500);
                });
                
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
            }
            
            handleResize() {
                const newSize = Math.min(window.innerWidth - 40, window.innerHeight - 100, 400);
                if (newSize !== this.gameSize) {
                    this.gameSize = newSize;
                    this.canvas.width = this.gameSize;
                    this.canvas.height = this.gameSize;
                    this.init();
                }
            }
            
            startOrientationTracking() {
                // Check if device supports orientation
                if (typeof DeviceOrientationEvent === 'undefined') {
                    this.orientationInfo.textContent = 'Device orientation not supported';
                    return;
                }
                
                // Request permission for iOS 13+
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                this.initOrientation();
                            } else {
                                this.orientationInfo.textContent = 'Permission denied for orientation';
                            }
                        })
                        .catch(console.error);
                } else {
                    this.initOrientation();
                }
            }
            
            initOrientation() {
                // Try to use GyroNorm if available
                if (typeof GyroNorm !== 'undefined') {
                    this.gn = new GyroNorm();
                    
                    this.gn.init().then(() => {
                        this.gn.start((data) => {
                            this.handleGyroNormData(data);
                        });
                    }).catch((e) => {
                        console.log('GyroNorm error:', e);
                        this.fallbackOrientation();
                    });
                } else {
                    this.fallbackOrientation();
                }
            }
            
            fallbackOrientation() {
                // Fallback to regular device orientation
                window.addEventListener('deviceorientation', (event) => {
                    this.handleDeviceOrientation(event);
                });
            }
            
            handleGyroNormData(data) {
                // GyroNorm provides do (device orientation) data
                const beta = data.do.beta;   // front-to-back tilt (-180 to 180)
                const gamma = data.do.gamma; // left-to-right tilt (-90 to 90)
                
                // Convert orientation to gravity
                const gravityStrength = 0.0008;
                const gravityX = Math.sin(gamma * Math.PI / 180) * gravityStrength;
                const gravityY = Math.sin(beta * Math.PI / 180) * gravityStrength;
                
                this.engine.world.gravity.x = gravityX;
                this.engine.world.gravity.y = gravityY;
                
                this.orientationInfo.textContent = `β: ${beta.toFixed(1)}° γ: ${gamma.toFixed(1)}° (GyroNorm)`;
            }
            
            handleDeviceOrientation(event) {
                const beta = event.beta;   // front-to-back tilt
                const gamma = event.gamma; // left-to-right tilt
                
                if (beta !== null && gamma !== null) {
                    const gravityStrength = 0.0008;
                    const gravityX = Math.sin(gamma * Math.PI / 180) * gravityStrength;
                    const gravityY = Math.sin(beta * Math.PI / 180) * gravityStrength;
                    
                    this.engine.world.gravity.x = gravityX;
                    this.engine.world.gravity.y = gravityY;
                    
                    this.orientationInfo.textContent = `β: ${beta.toFixed(1)}° γ: ${gamma.toFixed(1)}° (Fallback)`;
                }
            }
            
            updateTrail() {
                // Add current position to trail
                this.trail.push({
                    x: this.ball.position.x,
                    y: this.ball.position.y,
                    life: 1.0
                });
                
                // Remove old trail points
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // Update trail life
                this.trail.forEach((point, index) => {
                    point.life = (index + 1) / this.trail.length;
                });
            }
            
            render() {
                // Clear canvas with black background
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.gameSize, this.gameSize);
                
                // Draw canvas border for debugging
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(1, 1, this.gameSize - 2, this.gameSize - 2);
                
                // Update ball position display
                if (this.ball && this.ballPosInfo) {
                    this.ballPosInfo.textContent = `Ball: (${Math.round(this.ball.position.x)}, ${Math.round(this.ball.position.y)})`;
                }
                
                // Draw trail
                this.trail.forEach((point, index) => {
                    const alpha = point.life * 0.6;
                    const size = point.life * 8 + 2;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    // Create glow effect
                    const gradient = this.ctx.createRadialGradient(
                        point.x, point.y, 0,
                        point.x, point.y, size
                    );
                    gradient.addColorStop(0, '#ff6666');
                    gradient.addColorStop(0.5, '#ff0000');
                    gradient.addColorStop(1, 'transparent');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                });
                
                // Draw ball with bright red color and white outline
                if (this.ball) {
                    const ballX = this.ball.position.x;
                    const ballY = this.ball.position.y;
                    
                    // White outline
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(ballX, ballY, 22, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Red ball
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.beginPath();
                    this.ctx.arc(ballX, ballY, 20, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Add glow to ball
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.5;
                    const ballGradient = this.ctx.createRadialGradient(
                        ballX, ballY, 0,
                        ballX, ballY, 30
                    );
                    ballGradient.addColorStop(0, '#ff6666');
                    ballGradient.addColorStop(1, 'transparent');
                    
                    this.ctx.fillStyle = ballGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(ballX, ballY, 30, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                }
            }
            
            gameLoop() {
                // Update physics
                Matter.Engine.update(this.engine, 16.666);
                
                // Update trail
                this.updateTrail();
                
                // Render
                this.render();
                
                // Continue loop
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            new MobileBallGame();
        });
        
        // Handle iOS permission request on user interaction for GyroNorm
        document.addEventListener('click', function requestPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission();
            }
            document.removeEventListener('click', requestPermission);
        }, { once: true });
    </script>
</body>
</html>